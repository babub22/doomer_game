	    for(int side=0;side<basicSideCounter;side++){
	      WallType type = (grid[y][z][x].walls >> (side*8)) & 0xFF;

	      switch(type){
		/*case(doorT):{
		// should i use doorObj->pos insteadOf tile.x/y/z&
		Object* doorObj = grid[y][z][x].wallsData[side];
		DoorInfo* doorInfo = (DoorInfo*) doorObj->objInfo;

		// lb/rt only to intersection checking
		vec3 doorPos = {0};
		vec3 lb = {0};
		vec3 rt = {0};

		vec3 postRotationPos = { 0 };

		switch(side){
		case(top):{
		  if(doorInfo->opened){
		    lb = (vec3){tile.x + doorPad / 2 + doorW,tile.y,tile.z};
		    rt = (vec3){lb.x, tile.y+doorH, tile.z-doorW};
		  }else{
		    lb = (vec3){tile.x + doorPad / 2,tile.y,tile.z};
		    rt = (vec3){lb.x + doorW, tile.y+doorH, tile.z};
		  }

		  doorPos = (vec3){tile.x + doorPad / 2,tile.y,tile.z};

		  postRotationPos = (vec3){0, 0, 0.1f -doorPad};
		  break;
		}
		case(bot):{
		  if(doorInfo->opened){
		    lb = (vec3){tile.x + doorPad/2,tile.y, tile.z + blockW};
		    rt = (vec3){lb.x, tile.y+doorH, lb.z + doorW};
		  }else{
		    lb = (vec3){tile.x + doorPad/2,tile.y, tile.z + blockW};
		    rt = (vec3){lb.x+doorW, tile.y+doorH, tile.z + blockW};
		  }
	      
		  doorPos = (vec3){tile.x + doorPad / 2,tile.y,tile.z};
	      
		  postRotationPos = (vec3){-0.2f+doorPad, 0, -0.1f};
		  break;
		}
		case(left):{
		  if(doorInfo->opened){
		    lb = (vec3){tile.x, tile.y, tile.z + doorPad/2 + doorW};
		    rt = (vec3){tile.x-doorW, tile.y+doorH, lb.z};
		  }else{
		    lb = (vec3){tile.x, tile.y, tile.z + doorPad/2};
		    rt = (vec3){tile.x, tile.y+doorH, lb.z + doorW};
		  }

		  doorPos = (vec3){tile.x,tile.y,tile.z + doorPad/2};
	      
		  postRotationPos = (vec3){-0.1f+doorPad, 0, -0.1f+doorPad};
		  break;
		}
		case(right):{
		  if(doorInfo->opened){
		    lb = (vec3){tile.x + blockW,tile.y, tile.z + doorPad/2};
		    rt = (vec3){lb.x + doorW, tile.y+doorH, lb.z};
		  }else{
		    lb = (vec3){tile.x + blockW,tile.y, tile.z + doorPad/2};
		    rt = (vec3){tile.x + blockW, tile.y+doorH, lb.z + doorW};
		  }
	      
		  doorPos = (vec3){tile.x,tile.y,tile.z + doorPad/2};
	      
		  postRotationPos = (vec3){-0.1f, 0, 0.1f};
		  break;
		}
		default: break;
		}
		
		float intersectionDistance = 0.0f;
		bool isIntersect = rayIntersectsTriangle(mouse.start,mouse.end,lb,rt, NULL, &intersectionDistance);

		if(isIntersect && minIntersectionDist > intersectionDistance){
		  mouse.wallSide = side;
		  mouse.selectedTile = &grid[y][z][x];
		  mouse.wallTile = (vec3){x,y,z};

		  minIntersectionDist = intersectionDistance;
		  
		  if(mouse.clickL && doorObj->anim.frames == 0){
		    doorInfo->opened = !doorInfo->opened;
		  }
		}

		GLenum mode = isIntersect ? GL_TRIANGLE_STRIP : GL_LINES;
		
		if(doorInfo->opened){
		  glPushMatrix();
		  glTranslatef(doorPos.x, doorPos.y, doorPos.z);
		  glRotatef(90, 0, 1, 0);
		  glTranslatef(-doorPos.x, -doorPos.y, -doorPos.z);
		  glTranslatef(postRotationPos.x,postRotationPos.y,postRotationPos.z);
		}

		if(side == left || side == right){
		  renderWall(doorPos, mode, blockD, doorW, side, doorH, blueColor);
		}else{
		  renderWall(doorPos, mode, doorW, blockD, side, doorH, blueColor);
		}

		if(doorInfo->opened){
		  glPopMatrix();
		  break;
		}

		break;
	      }*/
















	    // render brush phantom
	    /*case(doorT):{
	      vec3 doorPos = {tile.x + doorPad / 2,tile.y,tile.z };
	      
	      if(mouse.tileSide == left || mouse.tileSide == right){
		doorPos.z += doorPad/2;
		renderWall(doorPos, GL_TRIANGLE_STRIP, blockD, doorW, mouse.tileSide, doorH, blueColor);
	      }else{
		renderWall(doorPos, GL_TRIANGLE_STRIP, doorW, blockD, mouse.tileSide, doorH, blueColor);
	      }
	       
	      break;
	    }*/
	    /*
		case(windowLeftT): {
	      //vec3* wallPos = wallPosBySide(tile, side, blockH, wallD, blockD, blockW);

	      break;
	    }
	    case(windowRightT):{
	      
	      break;
	    }
		*/




	      if(mouse.clickR){
		// delete if something exist on this place
		{
		  WallType type = (mouse.selectedTile->walls >> (mouse.tileSide*8)) & 0xFF;

		  if(type){
		    mouse.selectedTile->walls &= ~(0xFF << (mouse.tileSide * 8));

		    /* if(type == doorT){
		      int newSize = 0;
	    
		      for(int side=basicSideCounter;side!=0;side--){
			if (((mouse.selectedTile->walls >> ((side-1) * 8)) & 0xFF) == doorT) {
			  newSize = side;
			  break;
			};
		      }

		      if(newSize==0){
			free(mouse.selectedTile->wallsData);
			mouse.selectedTile->wallsData = NULL;
		      } else if(mouse.tileSide+1 > newSize) {
			mouse.selectedTile->wallsData = realloc(mouse.selectedTile->wallsData, newSize * sizeof(Object*));
		      }
		    }*/
		  }
		}
	      

		/*if(mouse.brush == doorT){
		  int wallsSize = 0;

		  // to get wallsSize can be optimized
		  // to O(4) -> O(1) by using if's 
		  if(grid[floor][z][x].walls !=0){
		    for(int side=basicSideCounter;side!=0;side--){
		      if (((grid[floor][z][x].walls >> ((side-1) * 8)) & 0xFF) == doorT) {
			wallsSize = side;
			break;
		      };
		    }
		  }
		  
		  if(mouse.tileSide+1 > wallsSize) {
		    if (!grid[floor][z][x].wallsData) {
		      grid[floor][z][x].wallsData = malloc((mouse.tileSide + 1) * sizeof(Object*));
		    }
		    else {
		      grid[floor][z][x].wallsData = realloc(grid[floor][z][x].wallsData, (mouse.tileSide + 1) * sizeof(Object*));
		    }
		  }
	      	      
		  Object* newDoor = doorConstructor((vec3){x,floor,z}, false);
		  
		  grid[floor][z][x].wallsData[mouse.tileSide] = newDoor;
		
		  addObjToStore(newDoor);

		  grid[floor][z][x].walls |= (mouse.brush << mouse.tileSide*8);
		}else{*/
		  Side oppositeSide = 0;
		  vec2i oppositeTile = {0};

		  setIn(&grid[floor][z][x].walls, mouse.tileSide, mouse.brush);
		  setIn(&grid[floor][z][x].wallsTx, mouse.tileSide, 0); // first texture
		  
		  if(oppositeTileTo((vec2i){x, z}, mouse.tileSide,&oppositeTile,&oppositeSide)){
		    grid[floor][(int)oppositeTile.z][(int)oppositeTile.x].walls |= (mouse.brush << oppositeSide*8);
		  }
	      }
	    }

